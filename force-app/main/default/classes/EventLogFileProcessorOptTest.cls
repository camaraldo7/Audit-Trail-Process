/**
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚                     EVENT LOG FILE PROCESSOR OPT TEST                    â”‚
 * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 * â”‚ Tests unitaires pour le traitement optimisÃ© des fichiers journaux        â”‚
 * â”‚ Couverture de code visÃ©e: 100%                                           â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 * @description       : 
 * @author            : Mamadou Lamine CAMARA
 * @group             : 
 * @last modified on  : 20-04-2025 
 * @last modified by  : Mamadou Lamine CAMARA
**/

@IsTest
public class EventLogFileProcessorOptTest {
    
    //â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    //â”‚    DONNÃ‰ES DE TEST                      â”‚
    //â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    private static final Id MOCK_USER_ID = '005000000000000';
    
    @TestSetup
    static void setupTestData() {
        // ğŸ‘¤ CrÃ©ation d'un utilisateur de test
        Profile p = [SELECT Id FROM Profile WHERE Name = 'Standard User' LIMIT 1];
        Map<String, Object> userFields = new Map<String, Object>{
            'LastName' => 'Test User',
            'Email' => DataFactoryG.generateRandomEmail(),
            'Alias' => DataFactoryG.generateRandomString(8).substring(0, 8),
            'Username' => DataFactoryG.generateRandomString(8) + '@test.com',
            'CommunityNickname' => DataFactoryG.generateRandomString(8),
            'EmailEncodingKey' => 'UTF-8',
            'LanguageLocaleKey' => 'fr',
            'LocaleSidKey' => 'fr_FR',
            'TimeZoneSidKey' => 'Europe/Paris',
            'ProfileId' => p.Id
        };
        User testUser = (User)DataFactoryG.createSObject('User', userFields);
        insert testUser;
    }
    
    //â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    //â”‚    MÃ‰THODES UTILITAIRES                 â”‚
    //â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    /**
     * @description CrÃ©e un EventLogFile simulÃ©
     */
    private static EventLogFile createMockEventLogFile(String eventType, String content) {
        return new EventLogFile(
            Id = 'abc123000000000000',
            EventType = eventType,
            LogDate = System.today(),
            LogFile = Blob.valueOf(content),
            LogFileLength = content.length()
        );
    }
    
    //â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    //â”‚    TESTS PRINCIPAUX                     â”‚
    //â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    /**
     * @description Test de rÃ©cupÃ©ration des fichiers journaux
     */
    @IsTest
    static void testGetEventLogFiles() {
        // ğŸ“ PrÃ©paration
        String loginContent = JSON.serialize(new Map<String, Object>{
            'UserId' => MOCK_USER_ID,
            'EventType' => 'Login',
            'LOGIN_TYPE' => 'Application',
            'STATUS' => 'Success'
        });
        EventLogFile mockLog = createMockEventLogFile('Login', loginContent);
        
        // ğŸ”§ Configuration du test
        Test.setFixedSearchResults(new List<Id>{mockLog.Id});
        
        // â–¶ï¸ ExÃ©cution
        Test.startTest();
        EventLogFileProcessorOpt processor = new EventLogFileProcessorOpt();
        List<EventLogFile> results = processor.getEventLogFiles(
            System.today().addDays(-1),
            System.today().addDays(1)
        );
        Test.stopTest();
        
        // âœ… VÃ©rifications
        System.assertEquals(1, results.size(), 'Un fichier journal devrait Ãªtre retournÃ©');
        System.assertEquals('Login', results[0].EventType, 'Le type d\'Ã©vÃ©nement devrait Ãªtre Login');
    }
    
    /**
     * @description Test du traitement des fichiers journaux de connexion
     */
    @IsTest
    static void testProcessLoginEventLogs() {
        // ğŸ“ PrÃ©paration
        String loginContent = JSON.serialize(new Map<String, Object>{
            'UserId' => MOCK_USER_ID,
            'EventType' => 'Login',
            'LOGIN_TYPE' => 'Application',
            'STATUS' => 'Success'
        });
        EventLogFile mockLog = createMockEventLogFile('Login', loginContent);
        
        // ğŸ”§ Configuration du test
        Test.setFixedSearchResults(new List<Id>{mockLog.Id});
        
        // â–¶ï¸ ExÃ©cution
        Test.startTest();
        EventLogFileProcessorOpt processor = new EventLogFileProcessorOpt();
        List<EventLogFileProcessorOpt.EventLogInfo> results = processor.processEventLogs(
            System.today().addDays(-1),
            System.today().addDays(1)
        );
        Test.stopTest();
        
        // âœ… VÃ©rifications
        System.assertNotEquals(0, results.size(), 'Des rÃ©sultats devraient Ãªtre retournÃ©s');
        EventLogFileProcessorOpt.EventLogInfo firstLog = results[0];
        System.assertEquals('Login', firstLog.eventType, 'Le type d\'Ã©vÃ©nement devrait Ãªtre Login');
        System.assertEquals(MOCK_USER_ID, firstLog.userId, 'L\'ID utilisateur devrait correspondre');
        System.assertEquals('Application', firstLog.additionalInfo.get('LOGIN_TYPE'), 'Le type de login devrait Ãªtre Application');
    }
    
    /**
     * @description Test du traitement des fichiers journaux d'API
     */
    @IsTest
    static void testProcessAPIEventLogs() {
        // ğŸ“ PrÃ©paration
        String apiContent = JSON.serialize(new Map<String, Object>{
            'UserId' => MOCK_USER_ID,
            'EventType' => 'API',
            'OPERATION' => 'Query',
            'STATUS_CODE' => '200',
            'API_VERSION' => '57.0'
        });
        EventLogFile mockLog = createMockEventLogFile('API', apiContent);
        
        // ğŸ”§ Configuration du test
        Test.setFixedSearchResults(new List<Id>{mockLog.Id});
        
        // â–¶ï¸ ExÃ©cution
        Test.startTest();
        EventLogFileProcessorOpt processor = new EventLogFileProcessorOpt();
        List<EventLogFileProcessorOpt.EventLogInfo> results = processor.processEventLogs(
            System.today().addDays(-1),
            System.today().addDays(1)
        );
        Test.stopTest();
        
        // âœ… VÃ©rifications
        System.assertNotEquals(0, results.size(), 'Des rÃ©sultats devraient Ãªtre retournÃ©s');
        EventLogFileProcessorOpt.EventLogInfo firstLog = results[0];
        System.assertEquals('API', firstLog.eventType, 'Le type d\'Ã©vÃ©nement devrait Ãªtre API');
        System.assertEquals('Query', firstLog.additionalInfo.get('OPERATION'), 'L\'opÃ©ration devrait Ãªtre Query');
    }
    
    /**
     * @description Test du traitement des fichiers journaux au format CSV
     */
    @IsTest
    static void testProcessCSVEventLogs() {
        // ğŸ“ PrÃ©paration
        String csvContent = 'USER_ID,LOGIN_TYPE,STATUS\n' +
                          MOCK_USER_ID + ',Application,Success';
        EventLogFile mockLog = createMockEventLogFile('Login', csvContent);
        
        // ğŸ”§ Configuration du test
        Test.setFixedSearchResults(new List<Id>{mockLog.Id});
        
        // â–¶ï¸ ExÃ©cution
        Test.startTest();
        EventLogFileProcessorOpt processor = new EventLogFileProcessorOpt();
        List<EventLogFileProcessorOpt.EventLogInfo> results = processor.processEventLogs(
            System.today().addDays(-1),
            System.today().addDays(1)
        );
        Test.stopTest();
        
        // âœ… VÃ©rifications
        System.assertNotEquals(0, results.size(), 'Des rÃ©sultats devraient Ãªtre retournÃ©s');
        EventLogFileProcessorOpt.EventLogInfo firstLog = results[0];
        System.assertEquals('Login', firstLog.eventType, 'Le type d\'Ã©vÃ©nement devrait Ãªtre Login');
        System.assertEquals(MOCK_USER_ID, firstLog.userId, 'L\'ID utilisateur devrait correspondre');
    }
    
    /**
     * @description Test du traitement des fichiers journaux invalides
     */
    @IsTest
    static void testProcessInvalidEventLogs() {
        // ğŸ“ PrÃ©paration
        EventLogFile mockLog = createMockEventLogFile('Unknown', 'Contenu invalide');
        
        // ğŸ”§ Configuration du test
        Test.setFixedSearchResults(new List<Id>{mockLog.Id});
        
        // â–¶ï¸ ExÃ©cution
        Test.startTest();
        EventLogFileProcessorOpt processor = new EventLogFileProcessorOpt();
        List<EventLogFileProcessorOpt.EventLogInfo> results = processor.processEventLogs(
            System.today().addDays(-1),
            System.today().addDays(1)
        );
        Test.stopTest();
        
        // âœ… VÃ©rifications
        System.assertNotEquals(0, results.size(), 'Des rÃ©sultats devraient Ãªtre retournÃ©s');
        EventLogFileProcessorOpt.EventLogInfo firstLog = results[0];
        System.assertEquals('Unknown', firstLog.eventType, 'Le type d\'Ã©vÃ©nement devrait Ãªtre Unknown');
    }
    
    /**
     * @description Test des cas d'erreur de validation des dates
     */
    @IsTest
    static void testDateValidationErrors() {
        // â–¶ï¸ ExÃ©cution avec dates nulles
        Test.startTest();
        EventLogFileProcessorOpt processor = new EventLogFileProcessorOpt();
        
        try {
            processor.getEventLogFiles(null, null);
            System.assert(false, 'Une exception aurait dÃ» Ãªtre levÃ©e pour des dates nulles');
        } catch (EventLogFileProcessorOpt.EventLogProcessorException e) {
            System.assert(e.getMessage().contains('requises'), 'Message d\'erreur incorrect');
        }
        
        try {
            processor.getEventLogFiles(
                System.today().addDays(1),
                System.today().addDays(-1)
            );
            System.assert(false, 'Une exception aurait dÃ» Ãªtre levÃ©e pour des dates invalides');
        } catch (EventLogFileProcessorOpt.EventLogProcessorException e) {
            System.assert(e.getMessage().contains('antÃ©rieure'), 'Message d\'erreur incorrect');
        }
        Test.stopTest();
    }
    
    /**
     * @description Test du traitement d'un fichier journal individuel
     */
    @IsTest
    static void testProcessSingleEventLogFile() {
        // ğŸ“ PrÃ©paration
        String loginContent = JSON.serialize(new Map<String, Object>{
            'UserId' => MOCK_USER_ID,
            'EventType' => 'Login',
            'LOGIN_TYPE' => 'Application',
            'STATUS' => 'Success'
        });
        EventLogFile mockLog = createMockEventLogFile('Login', loginContent);
        
        // â–¶ï¸ ExÃ©cution
        Test.startTest();
        EventLogFileProcessorOpt processor = new EventLogFileProcessorOpt();
        EventLogFileProcessorOpt.EventLogInfo result = processor.processEventLogFile(mockLog);
        Test.stopTest();
        
        // âœ… VÃ©rifications
        System.assertNotEquals(null, result, 'Le rÃ©sultat ne devrait pas Ãªtre null');
        System.assertEquals(mockLog.Id, result.logFileId, 'L\'ID du fichier journal devrait correspondre');
        System.assertEquals('Login', result.eventType, 'Le type d\'Ã©vÃ©nement devrait Ãªtre Login');
        System.assertEquals(MOCK_USER_ID, result.userId, 'L\'ID utilisateur devrait correspondre');
    }
} 